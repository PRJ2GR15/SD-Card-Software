
sdCardDriver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800200  000008f2  00000966  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000008f2  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .stab         0000096c  00000000  00000000  00000968  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      0000014d  00000000  00000000  000012d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000120  00000000  00000000  00001428  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000103a  00000000  00000000  00001548  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000682  00000000  00000000  00002582  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000086a  00000000  00000000  00002c04  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000254  00000000  00000000  00003470  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000003a6  00000000  00000000  000036c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000006d0  00000000  00000000  00003a6a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
   4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
   8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
   c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  10:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  14:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  18:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  1c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  20:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  24:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  28:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  2c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  30:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  34:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  38:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  3c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  40:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  44:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  48:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  4c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  50:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  54:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  58:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  5c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  60:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  64:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  68:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  6c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  70:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  74:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  78:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  7c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  80:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  84:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  88:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  8c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  90:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  94:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  98:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  9c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  a0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  a4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  a8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  ac:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  b0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  b4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  b8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  bc:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  c0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  c4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  c8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  cc:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  d0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  d4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  d8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  dc:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  e0:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
  f4:	12 e0       	ldi	r17, 0x02	; 2
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	e2 ef       	ldi	r30, 0xF2	; 242
  fc:	f8 e0       	ldi	r31, 0x08	; 8
  fe:	00 e0       	ldi	r16, 0x00	; 0
 100:	0b bf       	out	0x3b, r16	; 59
 102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
 104:	07 90       	elpm	r0, Z+
 106:	0d 92       	st	X+, r0
 108:	a0 30       	cpi	r26, 0x00	; 0
 10a:	b1 07       	cpc	r27, r17
 10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>
 10e:	1b be       	out	0x3b, r1	; 59

00000110 <__do_clear_bss>:
 110:	12 e0       	ldi	r17, 0x02	; 2
 112:	a0 e0       	ldi	r26, 0x00	; 0
 114:	b2 e0       	ldi	r27, 0x02	; 2
 116:	01 c0       	rjmp	.+2      	; 0x11a <.do_clear_bss_start>

00000118 <.do_clear_bss_loop>:
 118:	1d 92       	st	X+, r1

0000011a <.do_clear_bss_start>:
 11a:	a0 30       	cpi	r26, 0x00	; 0
 11c:	b1 07       	cpc	r27, r17
 11e:	e1 f7       	brne	.-8      	; 0x118 <.do_clear_bss_loop>
 120:	0e 94 96 00 	call	0x12c	; 0x12c <main>
 124:	0c 94 77 04 	jmp	0x8ee	; 0x8ee <_exit>

00000128 <__bad_interrupt>:
 128:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012c <main>:

#include "UART/uart.h"
#include "sd/sdCard.h"
#include <util/delay.h>
int main(void)
{
 12c:	ef 92       	push	r14
 12e:	ff 92       	push	r15
 130:	0f 93       	push	r16
 132:	1f 93       	push	r17
 134:	cf 93       	push	r28
 136:	df 93       	push	r29
 138:	cd b7       	in	r28, 0x3d	; 61
 13a:	de b7       	in	r29, 0x3e	; 62
 13c:	c3 50       	subi	r28, 0x03	; 3
 13e:	d2 40       	sbci	r29, 0x02	; 2
 140:	0f b6       	in	r0, 0x3f	; 63
 142:	f8 94       	cli
 144:	de bf       	out	0x3e, r29	; 62
 146:	0f be       	out	0x3f, r0	; 63
 148:	cd bf       	out	0x3d, r28	; 61

	InitUART(9600, 8, 0);
 14a:	60 e8       	ldi	r22, 0x80	; 128
 14c:	75 e2       	ldi	r23, 0x25	; 37
 14e:	80 e0       	ldi	r24, 0x00	; 0
 150:	90 e0       	ldi	r25, 0x00	; 0
 152:	48 e0       	ldi	r20, 0x08	; 8
 154:	20 e0       	ldi	r18, 0x00	; 0
 156:	0e 94 7e 03 	call	0x6fc	; 0x6fc <_Z8InitUARTmhc>
	sdCard SD_obj(4000);
 15a:	ce 01       	movw	r24, r28
 15c:	01 96       	adiw	r24, 0x01	; 1
 15e:	60 ea       	ldi	r22, 0xA0	; 160
 160:	7f e0       	ldi	r23, 0x0F	; 15
 162:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <_ZN6sdCardC1Ei>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 166:	8f e3       	ldi	r24, 0x3F	; 63
 168:	9c e9       	ldi	r25, 0x9C	; 156
 16a:	01 97       	sbiw	r24, 0x01	; 1
 16c:	f1 f7       	brne	.-4      	; 0x16a <main+0x3e>
 16e:	00 c0       	rjmp	.+0      	; 0x170 <main+0x44>
 170:	00 00       	nop
	_delay_ms(10);
	SendChar(SD_obj.init());
 172:	ce 01       	movw	r24, r28
 174:	01 96       	adiw	r24, 0x01	; 1
 176:	0e 94 46 01 	call	0x28c	; 0x28c <_ZN6sdCard4initEv>
 17a:	0e 94 db 03 	call	0x7b6	; 0x7b6 <_Z8SendCharc>
	//
	//
	//SendChar(0xBB);
	//SendChar(0xBB);
	//SendChar(0xBB);
	SD_obj.readBlock(0x00000200, Data);
 17e:	ce 01       	movw	r24, r28
 180:	01 96       	adiw	r24, 0x01	; 1
 182:	40 e0       	ldi	r20, 0x00	; 0
 184:	52 e0       	ldi	r21, 0x02	; 2
 186:	60 e0       	ldi	r22, 0x00	; 0
 188:	70 e0       	ldi	r23, 0x00	; 0
 18a:	9e 01       	movw	r18, r28
 18c:	2c 5f       	subi	r18, 0xFC	; 252
 18e:	3f 4f       	sbci	r19, 0xFF	; 255
 190:	0e 94 d7 02 	call	0x5ae	; 0x5ae <_ZN6sdCard9readBlockEmPh>
	SendChar(0xBB);
 194:	8b eb       	ldi	r24, 0xBB	; 187
 196:	0e 94 db 03 	call	0x7b6	; 0x7b6 <_Z8SendCharc>
	SendChar(0xBB);
 19a:	8b eb       	ldi	r24, 0xBB	; 187
 19c:	0e 94 db 03 	call	0x7b6	; 0x7b6 <_Z8SendCharc>
 1a0:	ee 24       	eor	r14, r14
 1a2:	ff 24       	eor	r15, r15
 1a4:	68 94       	set
 1a6:	e2 f8       	bld	r14, 2
 1a8:	ec 0e       	add	r14, r28
 1aa:	fd 1e       	adc	r15, r29
#include <avr/io.h>

#include "UART/uart.h"
#include "sd/sdCard.h"
#include <util/delay.h>
int main(void)
 1ac:	8e 01       	movw	r16, r28
 1ae:	0c 5f       	subi	r16, 0xFC	; 252
 1b0:	1d 4f       	sbci	r17, 0xFD	; 253
	//SendChar(0xBB);
	SD_obj.readBlock(0x00000200, Data);
	SendChar(0xBB);
	SendChar(0xBB);
	for( int j = 0; j < 512; j++){
		SendChar(Data[j]);
 1b2:	f7 01       	movw	r30, r14
 1b4:	81 91       	ld	r24, Z+
 1b6:	7f 01       	movw	r14, r30
 1b8:	0e 94 db 03 	call	0x7b6	; 0x7b6 <_Z8SendCharc>
	//SendChar(0xBB);
	//SendChar(0xBB);
	SD_obj.readBlock(0x00000200, Data);
	SendChar(0xBB);
	SendChar(0xBB);
	for( int j = 0; j < 512; j++){
 1bc:	e0 16       	cp	r14, r16
 1be:	f1 06       	cpc	r15, r17
 1c0:	c1 f7       	brne	.-16     	; 0x1b2 <main+0x86>
		SendChar(Data[j]);
	}
 1c2:	80 e0       	ldi	r24, 0x00	; 0
 1c4:	90 e0       	ldi	r25, 0x00	; 0
 1c6:	cd 5f       	subi	r28, 0xFD	; 253
 1c8:	dd 4f       	sbci	r29, 0xFD	; 253
 1ca:	0f b6       	in	r0, 0x3f	; 63
 1cc:	f8 94       	cli
 1ce:	de bf       	out	0x3e, r29	; 62
 1d0:	0f be       	out	0x3f, r0	; 63
 1d2:	cd bf       	out	0x3d, r28	; 61
 1d4:	df 91       	pop	r29
 1d6:	cf 91       	pop	r28
 1d8:	1f 91       	pop	r17
 1da:	0f 91       	pop	r16
 1dc:	ff 90       	pop	r15
 1de:	ef 90       	pop	r14
 1e0:	08 95       	ret

000001e2 <_ZN6sdCardC1Ei>:
 // METHOD : sdCard Constructor
 // DESCR. : runs the initiation sequence of the sd card and sets 
 // SPI to the supplied speed
 //=============================================================
 
 sdCard::sdCard( int speed ) : spi_obj(125)
 1e2:	0f 93       	push	r16
 1e4:	1f 93       	push	r17
 1e6:	cf 93       	push	r28
 1e8:	df 93       	push	r29
 1ea:	ec 01       	movw	r28, r24
 1ec:	8b 01       	movw	r16, r22
 1ee:	6d e7       	ldi	r22, 0x7D	; 125
 1f0:	70 e0       	ldi	r23, 0x00	; 0
 1f2:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <_ZN3SPIC1Ei>
 {
	 this->speed = speed; 
 1f6:	1a 83       	std	Y+2, r17	; 0x02
 1f8:	09 83       	std	Y+1, r16	; 0x01

 }
 1fa:	df 91       	pop	r29
 1fc:	cf 91       	pop	r28
 1fe:	1f 91       	pop	r17
 200:	0f 91       	pop	r16
 202:	08 95       	ret

00000204 <_ZN6sdCard11sendCommandEhmh>:
// METHOD : sendCommand
// DESCR. : takes a cmd index, an argument and a CRC and creates
// and sends the command to the sd card.
//=============================================================
void sdCard::sendCommand( unsigned char cmdindex, unsigned long argument, unsigned char CRC )
{
 204:	ef 92       	push	r14
 206:	ff 92       	push	r15
 208:	0f 93       	push	r16
 20a:	1f 93       	push	r17
 20c:	cf 93       	push	r28
 20e:	df 93       	push	r29
 210:	00 d0       	rcall	.+0      	; 0x212 <_ZN6sdCard11sendCommandEhmh+0xe>
 212:	0f 92       	push	r0
 214:	cd b7       	in	r28, 0x3d	; 61
 216:	de b7       	in	r29, 0x3e	; 62
 218:	18 2f       	mov	r17, r24
 21a:	e9 2e       	mov	r14, r25
 21c:	f6 2e       	mov	r15, r22
 21e:	29 83       	std	Y+1, r18	; 0x01
 220:	3a 83       	std	Y+2, r19	; 0x02
 222:	4b 83       	std	Y+3, r20	; 0x03
 224:	5c 83       	std	Y+4, r21	; 0x04
	unsigned char *argument_byte_pointer = (unsigned char*)&argument; // creating a pointer to extract bytes to be send.
	spi_obj.writeByte(0xFF); // prepare the sd card by sending 8 clock pulses.
 226:	6f ef       	ldi	r22, 0xFF	; 255
 228:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(0b01000000 | cmdindex);
 22c:	6f 2d       	mov	r22, r15
 22e:	60 64       	ori	r22, 0x40	; 64
 230:	81 2f       	mov	r24, r17
 232:	9e 2d       	mov	r25, r14
 234:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(argument_byte_pointer[0]);
 238:	81 2f       	mov	r24, r17
 23a:	9e 2d       	mov	r25, r14
 23c:	69 81       	ldd	r22, Y+1	; 0x01
 23e:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(argument_byte_pointer[1]);
 242:	81 2f       	mov	r24, r17
 244:	9e 2d       	mov	r25, r14
 246:	6a 81       	ldd	r22, Y+2	; 0x02
 248:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(argument_byte_pointer[3]);
 24c:	81 2f       	mov	r24, r17
 24e:	9e 2d       	mov	r25, r14
 250:	6c 81       	ldd	r22, Y+4	; 0x04
 252:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(argument_byte_pointer[4]);
 256:	81 2f       	mov	r24, r17
 258:	9e 2d       	mov	r25, r14
 25a:	6d 81       	ldd	r22, Y+5	; 0x05
 25c:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(CRC);
 260:	81 2f       	mov	r24, r17
 262:	9e 2d       	mov	r25, r14
 264:	60 2f       	mov	r22, r16
 266:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
}
 26a:	0f 90       	pop	r0
 26c:	0f 90       	pop	r0
 26e:	0f 90       	pop	r0
 270:	0f 90       	pop	r0
 272:	df 91       	pop	r29
 274:	cf 91       	pop	r28
 276:	1f 91       	pop	r17
 278:	0f 91       	pop	r16
 27a:	ff 90       	pop	r15
 27c:	ef 90       	pop	r14
 27e:	08 95       	ret

00000280 <_ZN6sdCard14getResponeByteEv>:



unsigned char sdCard::getResponeByte()
{
	return spi_obj.recieveByte();
 280:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
}
 284:	08 95       	ret

00000286 <_ZN6sdCard9writeByteEh>:

void sdCard::writeByte( unsigned char bla)
{
	spi_obj.writeByte(bla);
 286:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
}
 28a:	08 95       	ret

0000028c <_ZN6sdCard4initEv>:

bool sdCard::init()
{
 28c:	af 92       	push	r10
 28e:	bf 92       	push	r11
 290:	cf 92       	push	r12
 292:	df 92       	push	r13
 294:	ef 92       	push	r14
 296:	ff 92       	push	r15
 298:	0f 93       	push	r16
 29a:	1f 93       	push	r17
 29c:	cf 93       	push	r28
 29e:	df 93       	push	r29
 2a0:	00 d0       	rcall	.+0      	; 0x2a2 <_ZN6sdCard4initEv+0x16>
 2a2:	0f 92       	push	r0
 2a4:	0f 92       	push	r0
 2a6:	cd b7       	in	r28, 0x3d	; 61
 2a8:	de b7       	in	r29, 0x3e	; 62
 2aa:	b8 2e       	mov	r11, r24
 2ac:	a9 2e       	mov	r10, r25
 2ae:	83 ef       	ldi	r24, 0xF3	; 243
 2b0:	91 e0       	ldi	r25, 0x01	; 1
 2b2:	01 97       	sbiw	r24, 0x01	; 1
 2b4:	f1 f7       	brne	.-4      	; 0x2b2 <_ZN6sdCard4initEv+0x26>
 2b6:	00 c0       	rjmp	.+0      	; 0x2b8 <_ZN6sdCard4initEv+0x2c>
 2b8:	00 00       	nop
	_delay_ms(2);
	PORTB = PINB | 0b00000001; // sets the SS pin ghigh
 2ba:	83 b1       	in	r24, 0x03	; 3
 2bc:	81 60       	ori	r24, 0x01	; 1
 2be:	85 b9       	out	0x05, r24	; 5
	spi_obj.setFreq(125); // frequency during initiation must be lower than 400 kHz.
 2c0:	cb 2c       	mov	r12, r11
 2c2:	da 2c       	mov	r13, r10
 2c4:	8b 2d       	mov	r24, r11
 2c6:	9a 2d       	mov	r25, r10
 2c8:	6d e7       	ldi	r22, 0x7D	; 125
 2ca:	70 e0       	ldi	r23, 0x00	; 0
 2cc:	0e 94 42 03 	call	0x684	; 0x684 <_ZN3SPI7setFreqEi>
 2d0:	e3 ef       	ldi	r30, 0xF3	; 243
 2d2:	f1 e0       	ldi	r31, 0x01	; 1
 2d4:	31 97       	sbiw	r30, 0x01	; 1
 2d6:	f1 f7       	brne	.-4      	; 0x2d4 <_ZN6sdCard4initEv+0x48>
 2d8:	00 c0       	rjmp	.+0      	; 0x2da <_ZN6sdCard4initEv+0x4e>
 2da:	00 00       	nop
	_delay_ms(2); // let the clock settle in.
	
	// dummy cycles need to be moved to sdCard class.
	spi_obj.writeByte(0xFF);
 2dc:	8b 2d       	mov	r24, r11
 2de:	9a 2d       	mov	r25, r10
 2e0:	6f ef       	ldi	r22, 0xFF	; 255
 2e2:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(0xFF);
 2e6:	8b 2d       	mov	r24, r11
 2e8:	9a 2d       	mov	r25, r10
 2ea:	6f ef       	ldi	r22, 0xFF	; 255
 2ec:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(0xFF);
 2f0:	8b 2d       	mov	r24, r11
 2f2:	9a 2d       	mov	r25, r10
 2f4:	6f ef       	ldi	r22, 0xFF	; 255
 2f6:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(0xFF);
 2fa:	8b 2d       	mov	r24, r11
 2fc:	9a 2d       	mov	r25, r10
 2fe:	6f ef       	ldi	r22, 0xFF	; 255
 300:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(0xFF);
 304:	8b 2d       	mov	r24, r11
 306:	9a 2d       	mov	r25, r10
 308:	6f ef       	ldi	r22, 0xFF	; 255
 30a:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(0xFF);
 30e:	8b 2d       	mov	r24, r11
 310:	9a 2d       	mov	r25, r10
 312:	6f ef       	ldi	r22, 0xFF	; 255
 314:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(0xFF);
 318:	8b 2d       	mov	r24, r11
 31a:	9a 2d       	mov	r25, r10
 31c:	6f ef       	ldi	r22, 0xFF	; 255
 31e:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(0xFF);
 322:	8b 2d       	mov	r24, r11
 324:	9a 2d       	mov	r25, r10
 326:	6f ef       	ldi	r22, 0xFF	; 255
 328:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(0xFF);
 32c:	8b 2d       	mov	r24, r11
 32e:	9a 2d       	mov	r25, r10
 330:	6f ef       	ldi	r22, 0xFF	; 255
 332:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(0xFF);
 336:	8b 2d       	mov	r24, r11
 338:	9a 2d       	mov	r25, r10
 33a:	6f ef       	ldi	r22, 0xFF	; 255
 33c:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	
	unsigned char result = 0x00; // variable to store the result for error checking.
	do
	{
		PORTB = PINB & 0b11111110; // set the SS pin low
 340:	83 b1       	in	r24, 0x03	; 3
 342:	8e 7f       	andi	r24, 0xFE	; 254
 344:	85 b9       	out	0x05, r24	; 5
		// CMD0 needs to be moved to SD card class
		spi_obj.writeByte(0xFF); // dummy byte to let clock sync.
 346:	8c 2d       	mov	r24, r12
 348:	9d 2d       	mov	r25, r13
 34a:	6f ef       	ldi	r22, 0xFF	; 255
 34c:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x40); // cmd
 350:	8c 2d       	mov	r24, r12
 352:	9d 2d       	mov	r25, r13
 354:	60 e4       	ldi	r22, 0x40	; 64
 356:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x00); // no argument
 35a:	8c 2d       	mov	r24, r12
 35c:	9d 2d       	mov	r25, r13
 35e:	60 e0       	ldi	r22, 0x00	; 0
 360:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x00); // no argument
 364:	8c 2d       	mov	r24, r12
 366:	9d 2d       	mov	r25, r13
 368:	60 e0       	ldi	r22, 0x00	; 0
 36a:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x00); // no argument
 36e:	8c 2d       	mov	r24, r12
 370:	9d 2d       	mov	r25, r13
 372:	60 e0       	ldi	r22, 0x00	; 0
 374:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x00); // no argument
 378:	8c 2d       	mov	r24, r12
 37a:	9d 2d       	mov	r25, r13
 37c:	60 e0       	ldi	r22, 0x00	; 0
 37e:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x95); // CRC
 382:	8c 2d       	mov	r24, r12
 384:	9d 2d       	mov	r25, r13
 386:	65 e9       	ldi	r22, 0x95	; 149
 388:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.recieveByte(); // grab blank return before the real value is extracted
 38c:	8c 2d       	mov	r24, r12
 38e:	9d 2d       	mov	r25, r13
 390:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
		result = spi_obj.recieveByte(); // grab R1 return value
 394:	8c 2d       	mov	r24, r12
 396:	9d 2d       	mov	r25, r13
 398:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
	spi_obj.writeByte(0xFF);
	spi_obj.writeByte(0xFF);
	spi_obj.writeByte(0xFF);
	
	unsigned char result = 0x00; // variable to store the result for error checking.
	do
 39c:	8f 3f       	cpi	r24, 0xFF	; 255
 39e:	81 f2       	breq	.-96     	; 0x340 <_ZN6sdCard4initEv+0xb4>
		spi_obj.writeByte(0x95); // CRC
		spi_obj.recieveByte(); // grab blank return before the real value is extracted
		result = spi_obj.recieveByte(); // grab R1 return value
	} while (result == 0xFF);
	
	if(result == 0x01)
 3a0:	81 30       	cpi	r24, 0x01	; 1
 3a2:	09 f0       	breq	.+2      	; 0x3a6 <_ZN6sdCard4initEv+0x11a>
 3a4:	e9 c0       	rjmp	.+466    	; 0x578 <_ZN6sdCard4initEv+0x2ec>
	{
		// CMD8 needs to be moved to SD card class
		spi_obj.writeByte(0xFF); // Dummy byte to let clock sync
 3a6:	8b 2d       	mov	r24, r11
 3a8:	9a 2d       	mov	r25, r10
 3aa:	6f ef       	ldi	r22, 0xFF	; 255
 3ac:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x48); // CMD
 3b0:	8b 2d       	mov	r24, r11
 3b2:	9a 2d       	mov	r25, r10
 3b4:	68 e4       	ldi	r22, 0x48	; 72
 3b6:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x00); // argument data 4 bytes
 3ba:	8b 2d       	mov	r24, r11
 3bc:	9a 2d       	mov	r25, r10
 3be:	60 e0       	ldi	r22, 0x00	; 0
 3c0:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x00);
 3c4:	8b 2d       	mov	r24, r11
 3c6:	9a 2d       	mov	r25, r10
 3c8:	60 e0       	ldi	r22, 0x00	; 0
 3ca:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x01);
 3ce:	8b 2d       	mov	r24, r11
 3d0:	9a 2d       	mov	r25, r10
 3d2:	61 e0       	ldi	r22, 0x01	; 1
 3d4:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0xAA);
 3d8:	8b 2d       	mov	r24, r11
 3da:	9a 2d       	mov	r25, r10
 3dc:	6a ea       	ldi	r22, 0xAA	; 170
 3de:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x87); // CRC
 3e2:	8b 2d       	mov	r24, r11
 3e4:	9a 2d       	mov	r25, r10
 3e6:	67 e8       	ldi	r22, 0x87	; 135
 3e8:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	else
	{
		return false;
	}
	unsigned char cmd8result[5];
	spi_obj.recieveByte(); // grab useless data from pause before the real response.
 3ec:	8b 2d       	mov	r24, r11
 3ee:	9a 2d       	mov	r25, r10
 3f0:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
 3f4:	8e 01       	movw	r16, r28
 3f6:	0f 5f       	subi	r16, 0xFF	; 255
 3f8:	1f 4f       	sbci	r17, 0xFF	; 255
void sdCard::writeByte( unsigned char bla)
{
	spi_obj.writeByte(bla);
}

bool sdCard::init()
 3fa:	0f 2e       	mov	r0, r31
 3fc:	f6 e0       	ldi	r31, 0x06	; 6
 3fe:	ef 2e       	mov	r14, r31
 400:	ff 24       	eor	r15, r15
 402:	f0 2d       	mov	r31, r0
 404:	ec 0e       	add	r14, r28
 406:	fd 1e       	adc	r15, r29
	}
	unsigned char cmd8result[5];
	spi_obj.recieveByte(); // grab useless data from pause before the real response.
	for(int i = 0; i < 5; i++)
	{
		cmd8result[i] = spi_obj.recieveByte(); // fill in the response array
 408:	8c 2d       	mov	r24, r12
 40a:	9d 2d       	mov	r25, r13
 40c:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
 410:	f8 01       	movw	r30, r16
 412:	81 93       	st	Z+, r24
 414:	8f 01       	movw	r16, r30
	{
		return false;
	}
	unsigned char cmd8result[5];
	spi_obj.recieveByte(); // grab useless data from pause before the real response.
	for(int i = 0; i < 5; i++)
 416:	ee 15       	cp	r30, r14
 418:	ff 05       	cpc	r31, r15
 41a:	b1 f7       	brne	.-20     	; 0x408 <_ZN6sdCard4initEv+0x17c>
	{
		cmd8result[i] = spi_obj.recieveByte(); // fill in the response array
	}

	if( cmd8result[0] == 0x01 && cmd8result[1] == 0x00 && cmd8result[2] == 0x00 && cmd8result[3] == 0x01 && cmd8result[4] == 0xAA ) // validate that the card is sd v2
 41c:	89 81       	ldd	r24, Y+1	; 0x01
 41e:	81 30       	cpi	r24, 0x01	; 1
 420:	09 f0       	breq	.+2      	; 0x424 <_ZN6sdCard4initEv+0x198>
 422:	ac c0       	rjmp	.+344    	; 0x57c <_ZN6sdCard4initEv+0x2f0>
 424:	8a 81       	ldd	r24, Y+2	; 0x02
 426:	88 23       	and	r24, r24
 428:	09 f0       	breq	.+2      	; 0x42c <_ZN6sdCard4initEv+0x1a0>
 42a:	aa c0       	rjmp	.+340    	; 0x580 <_ZN6sdCard4initEv+0x2f4>
 42c:	8b 81       	ldd	r24, Y+3	; 0x03
 42e:	88 23       	and	r24, r24
 430:	09 f0       	breq	.+2      	; 0x434 <_ZN6sdCard4initEv+0x1a8>
 432:	a8 c0       	rjmp	.+336    	; 0x584 <_ZN6sdCard4initEv+0x2f8>
 434:	8c 81       	ldd	r24, Y+4	; 0x04
 436:	81 30       	cpi	r24, 0x01	; 1
 438:	09 f0       	breq	.+2      	; 0x43c <_ZN6sdCard4initEv+0x1b0>
 43a:	a6 c0       	rjmp	.+332    	; 0x588 <_ZN6sdCard4initEv+0x2fc>
 43c:	8d 81       	ldd	r24, Y+5	; 0x05
 43e:	8a 3a       	cpi	r24, 0xAA	; 170
 440:	09 f0       	breq	.+2      	; 0x444 <_ZN6sdCard4initEv+0x1b8>
 442:	a4 c0       	rjmp	.+328    	; 0x58c <_ZN6sdCard4initEv+0x300>
		// if cmd8 successfull start initiating the card
		do // loop fra ACMD41 untill card goes busy.
		{ 
		// CMD55 part of ACMD41
		
		spi_obj.writeByte(0xFF); // sync byte
 444:	8c 2d       	mov	r24, r12
 446:	9d 2d       	mov	r25, r13
 448:	6f ef       	ldi	r22, 0xFF	; 255
 44a:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x77); // CMD 55
 44e:	8c 2d       	mov	r24, r12
 450:	9d 2d       	mov	r25, r13
 452:	67 e7       	ldi	r22, 0x77	; 119
 454:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x00);
 458:	8c 2d       	mov	r24, r12
 45a:	9d 2d       	mov	r25, r13
 45c:	60 e0       	ldi	r22, 0x00	; 0
 45e:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x00);
 462:	8c 2d       	mov	r24, r12
 464:	9d 2d       	mov	r25, r13
 466:	60 e0       	ldi	r22, 0x00	; 0
 468:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x00);
 46c:	8c 2d       	mov	r24, r12
 46e:	9d 2d       	mov	r25, r13
 470:	60 e0       	ldi	r22, 0x00	; 0
 472:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x00);
 476:	8c 2d       	mov	r24, r12
 478:	9d 2d       	mov	r25, r13
 47a:	60 e0       	ldi	r22, 0x00	; 0
 47c:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0xFF); // dummy CRC since CRC should be off now;
 480:	8c 2d       	mov	r24, r12
 482:	9d 2d       	mov	r25, r13
 484:	6f ef       	ldi	r22, 0xFF	; 255
 486:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.recieveByte();
 48a:	8c 2d       	mov	r24, r12
 48c:	9d 2d       	mov	r25, r13
 48e:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
		
		result = spi_obj.recieveByte();
 492:	8c 2d       	mov	r24, r12
 494:	9d 2d       	mov	r25, r13
 496:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
	
		//rest of ACMD41
		spi_obj.writeByte(0xFF);
 49a:	8c 2d       	mov	r24, r12
 49c:	9d 2d       	mov	r25, r13
 49e:	6f ef       	ldi	r22, 0xFF	; 255
 4a0:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x69); // acmd41
 4a4:	8c 2d       	mov	r24, r12
 4a6:	9d 2d       	mov	r25, r13
 4a8:	69 e6       	ldi	r22, 0x69	; 105
 4aa:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x40); // HCS bit set high.
 4ae:	8c 2d       	mov	r24, r12
 4b0:	9d 2d       	mov	r25, r13
 4b2:	60 e4       	ldi	r22, 0x40	; 64
 4b4:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x00);
 4b8:	8c 2d       	mov	r24, r12
 4ba:	9d 2d       	mov	r25, r13
 4bc:	60 e0       	ldi	r22, 0x00	; 0
 4be:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x00);
 4c2:	8c 2d       	mov	r24, r12
 4c4:	9d 2d       	mov	r25, r13
 4c6:	60 e0       	ldi	r22, 0x00	; 0
 4c8:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x00);
 4cc:	8c 2d       	mov	r24, r12
 4ce:	9d 2d       	mov	r25, r13
 4d0:	60 e0       	ldi	r22, 0x00	; 0
 4d2:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0xFF); // dummy CRC
 4d6:	8c 2d       	mov	r24, r12
 4d8:	9d 2d       	mov	r25, r13
 4da:	6f ef       	ldi	r22, 0xFF	; 255
 4dc:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.recieveByte();
 4e0:	8c 2d       	mov	r24, r12
 4e2:	9d 2d       	mov	r25, r13
 4e4:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
		result = spi_obj.recieveByte();
 4e8:	8c 2d       	mov	r24, r12
 4ea:	9d 2d       	mov	r25, r13
 4ec:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
	}

	if( cmd8result[0] == 0x01 && cmd8result[1] == 0x00 && cmd8result[2] == 0x00 && cmd8result[3] == 0x01 && cmd8result[4] == 0xAA ) // validate that the card is sd v2
	{
		// if cmd8 successfull start initiating the card
		do // loop fra ACMD41 untill card goes busy.
 4f0:	88 23       	and	r24, r24
 4f2:	09 f0       	breq	.+2      	; 0x4f6 <_ZN6sdCard4initEv+0x26a>
 4f4:	a7 cf       	rjmp	.-178    	; 0x444 <_ZN6sdCard4initEv+0x1b8>
		
		//SendChar(result);
		} while(result != 0x00); // loop untill card goes busy, indicating the cmd was accepted.
	
		// sending command 58 to request OCR register
		spi_obj.writeByte(0xFF);
 4f6:	8b 2d       	mov	r24, r11
 4f8:	9a 2d       	mov	r25, r10
 4fa:	6f ef       	ldi	r22, 0xFF	; 255
 4fc:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x7A); // cmd 58
 500:	8b 2d       	mov	r24, r11
 502:	9a 2d       	mov	r25, r10
 504:	6a e7       	ldi	r22, 0x7A	; 122
 506:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x00);
 50a:	8b 2d       	mov	r24, r11
 50c:	9a 2d       	mov	r25, r10
 50e:	60 e0       	ldi	r22, 0x00	; 0
 510:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x00);
 514:	8b 2d       	mov	r24, r11
 516:	9a 2d       	mov	r25, r10
 518:	60 e0       	ldi	r22, 0x00	; 0
 51a:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x00);
 51e:	8b 2d       	mov	r24, r11
 520:	9a 2d       	mov	r25, r10
 522:	60 e0       	ldi	r22, 0x00	; 0
 524:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0x00);
 528:	8b 2d       	mov	r24, r11
 52a:	9a 2d       	mov	r25, r10
 52c:	60 e0       	ldi	r22, 0x00	; 0
 52e:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
		spi_obj.writeByte(0xFF); // dummy CRC;
 532:	8b 2d       	mov	r24, r11
 534:	9a 2d       	mov	r25, r10
 536:	6f ef       	ldi	r22, 0xFF	; 255
 538:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	
		unsigned char OCR[4]; // used to store the OCR register
	
		spi_obj.recieveByte();
 53c:	8b 2d       	mov	r24, r11
 53e:	9a 2d       	mov	r25, r10
 540:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
		spi_obj.recieveByte(); // R1 byte, not using the content of it here, as i'm keeping it simplified.
 544:	8b 2d       	mov	r24, r11
 546:	9a 2d       	mov	r25, r10
 548:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
		OCR[0] = spi_obj.recieveByte(); // getting the 4 bytes of OCR
 54c:	8b 2d       	mov	r24, r11
 54e:	9a 2d       	mov	r25, r10
 550:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
 554:	08 2f       	mov	r16, r24
		OCR[1] = spi_obj.recieveByte();
 556:	8b 2d       	mov	r24, r11
 558:	9a 2d       	mov	r25, r10
 55a:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
		OCR[2] = spi_obj.recieveByte();
 55e:	8b 2d       	mov	r24, r11
 560:	9a 2d       	mov	r25, r10
 562:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
		OCR[3] = spi_obj.recieveByte();
 566:	8b 2d       	mov	r24, r11
 568:	9a 2d       	mov	r25, r10
 56a:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
void sdCard::writeByte( unsigned char bla)
{
	spi_obj.writeByte(bla);
}

bool sdCard::init()
 56e:	81 e0       	ldi	r24, 0x01	; 1
 570:	06 fd       	sbrc	r16, 6
 572:	0d c0       	rjmp	.+26     	; 0x58e <_ZN6sdCard4initEv+0x302>
 574:	80 e0       	ldi	r24, 0x00	; 0
 576:	0b c0       	rjmp	.+22     	; 0x58e <_ZN6sdCard4initEv+0x302>
		spi_obj.writeByte(0x87); // CRC
		//0x48 00 00 01 AA 87
	}
	else
	{
		return false;
 578:	80 e0       	ldi	r24, 0x00	; 0
 57a:	09 c0       	rjmp	.+18     	; 0x58e <_ZN6sdCard4initEv+0x302>
			return false;
		}	
	} 
	else 
	{
		return false;
 57c:	80 e0       	ldi	r24, 0x00	; 0
 57e:	07 c0       	rjmp	.+14     	; 0x58e <_ZN6sdCard4initEv+0x302>
 580:	80 e0       	ldi	r24, 0x00	; 0
 582:	05 c0       	rjmp	.+10     	; 0x58e <_ZN6sdCard4initEv+0x302>
 584:	80 e0       	ldi	r24, 0x00	; 0
 586:	03 c0       	rjmp	.+6      	; 0x58e <_ZN6sdCard4initEv+0x302>
 588:	80 e0       	ldi	r24, 0x00	; 0
 58a:	01 c0       	rjmp	.+2      	; 0x58e <_ZN6sdCard4initEv+0x302>
 58c:	80 e0       	ldi	r24, 0x00	; 0
	}		
			
	
}
 58e:	0f 90       	pop	r0
 590:	0f 90       	pop	r0
 592:	0f 90       	pop	r0
 594:	0f 90       	pop	r0
 596:	0f 90       	pop	r0
 598:	df 91       	pop	r29
 59a:	cf 91       	pop	r28
 59c:	1f 91       	pop	r17
 59e:	0f 91       	pop	r16
 5a0:	ff 90       	pop	r15
 5a2:	ef 90       	pop	r14
 5a4:	df 90       	pop	r13
 5a6:	cf 90       	pop	r12
 5a8:	bf 90       	pop	r11
 5aa:	af 90       	pop	r10
 5ac:	08 95       	ret

000005ae <_ZN6sdCard9readBlockEmPh>:

bool sdCard::readBlock( unsigned long adress, unsigned char outputdata[] )
{
 5ae:	af 92       	push	r10
 5b0:	bf 92       	push	r11
 5b2:	cf 92       	push	r12
 5b4:	df 92       	push	r13
 5b6:	ef 92       	push	r14
 5b8:	ff 92       	push	r15
 5ba:	0f 93       	push	r16
 5bc:	1f 93       	push	r17
 5be:	cf 93       	push	r28
 5c0:	df 93       	push	r29
 5c2:	00 d0       	rcall	.+0      	; 0x5c4 <_ZN6sdCard9readBlockEmPh+0x16>
 5c4:	0f 92       	push	r0
 5c6:	cd b7       	in	r28, 0x3d	; 61
 5c8:	de b7       	in	r29, 0x3e	; 62
 5ca:	b8 2e       	mov	r11, r24
 5cc:	a9 2e       	mov	r10, r25
 5ce:	49 83       	std	Y+1, r20	; 0x01
 5d0:	5a 83       	std	Y+2, r21	; 0x02
 5d2:	6b 83       	std	Y+3, r22	; 0x03
 5d4:	7c 83       	std	Y+4, r23	; 0x04
 5d6:	02 2f       	mov	r16, r18
 5d8:	13 2f       	mov	r17, r19
	unsigned char *argument_byte_pointer = (unsigned char*)&adress;
	spi_obj.writeByte(0xFF); // clock sync
 5da:	c8 2e       	mov	r12, r24
 5dc:	d9 2e       	mov	r13, r25
 5de:	6f ef       	ldi	r22, 0xFF	; 255
 5e0:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(0x51);
 5e4:	8b 2d       	mov	r24, r11
 5e6:	9a 2d       	mov	r25, r10
 5e8:	61 e5       	ldi	r22, 0x51	; 81
 5ea:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(argument_byte_pointer[0]);
 5ee:	8b 2d       	mov	r24, r11
 5f0:	9a 2d       	mov	r25, r10
 5f2:	69 81       	ldd	r22, Y+1	; 0x01
 5f4:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(argument_byte_pointer[1]);
 5f8:	8b 2d       	mov	r24, r11
 5fa:	9a 2d       	mov	r25, r10
 5fc:	6a 81       	ldd	r22, Y+2	; 0x02
 5fe:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(argument_byte_pointer[2]);
 602:	8b 2d       	mov	r24, r11
 604:	9a 2d       	mov	r25, r10
 606:	6b 81       	ldd	r22, Y+3	; 0x03
 608:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(argument_byte_pointer[3]);
 60c:	8b 2d       	mov	r24, r11
 60e:	9a 2d       	mov	r25, r10
 610:	6c 81       	ldd	r22, Y+4	; 0x04
 612:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	spi_obj.writeByte(0xFF); // dummy CRC;
 616:	8b 2d       	mov	r24, r11
 618:	9a 2d       	mov	r25, r10
 61a:	6f ef       	ldi	r22, 0xFF	; 255
 61c:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN3SPI9writeByteEh>
	
	spi_obj.recieveByte(); // getting empty response out of the way.
 620:	8b 2d       	mov	r24, r11
 622:	9a 2d       	mov	r25, r10
 624:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
	unsigned char result;
	do 
	{
		result = spi_obj.recieveByte();
 628:	8c 2d       	mov	r24, r12
 62a:	9d 2d       	mov	r25, r13
 62c:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
	spi_obj.writeByte(argument_byte_pointer[3]);
	spi_obj.writeByte(0xFF); // dummy CRC;
	
	spi_obj.recieveByte(); // getting empty response out of the way.
	unsigned char result;
	do 
 630:	8e 3f       	cpi	r24, 0xFE	; 254
 632:	d1 f7       	brne	.-12     	; 0x628 <_ZN6sdCard9readBlockEmPh+0x7a>
 634:	e0 2e       	mov	r14, r16
 636:	f1 2e       	mov	r15, r17
 638:	00 e0       	ldi	r16, 0x00	; 0
 63a:	10 e0       	ldi	r17, 0x00	; 0
	{
		result = spi_obj.recieveByte();
	} while (result != 0xFE);
	
	for( int i = 0; i < 512; i++ ){ // filling up the supplied array with the data content of the requested block.
		outputdata[i] = spi_obj.recieveByte();
 63c:	8c 2d       	mov	r24, r12
 63e:	9d 2d       	mov	r25, r13
 640:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
 644:	f7 01       	movw	r30, r14
 646:	81 93       	st	Z+, r24
 648:	7f 01       	movw	r14, r30
	do 
	{
		result = spi_obj.recieveByte();
	} while (result != 0xFE);
	
	for( int i = 0; i < 512; i++ ){ // filling up the supplied array with the data content of the requested block.
 64a:	0f 5f       	subi	r16, 0xFF	; 255
 64c:	1f 4f       	sbci	r17, 0xFF	; 255
 64e:	f2 e0       	ldi	r31, 0x02	; 2
 650:	00 30       	cpi	r16, 0x00	; 0
 652:	1f 07       	cpc	r17, r31
 654:	99 f7       	brne	.-26     	; 0x63c <_ZN6sdCard9readBlockEmPh+0x8e>
		outputdata[i] = spi_obj.recieveByte();
	}
	spi_obj.recieveByte();
 656:	8b 2d       	mov	r24, r11
 658:	9a 2d       	mov	r25, r10
 65a:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>
	spi_obj.recieveByte();	
 65e:	8b 2d       	mov	r24, r11
 660:	9a 2d       	mov	r25, r10
 662:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN3SPI11recieveByteEv>

}
 666:	0f 90       	pop	r0
 668:	0f 90       	pop	r0
 66a:	0f 90       	pop	r0
 66c:	0f 90       	pop	r0
 66e:	df 91       	pop	r29
 670:	cf 91       	pop	r28
 672:	1f 91       	pop	r17
 674:	0f 91       	pop	r16
 676:	ff 90       	pop	r15
 678:	ef 90       	pop	r14
 67a:	df 90       	pop	r13
 67c:	cf 90       	pop	r12
 67e:	bf 90       	pop	r11
 680:	af 90       	pop	r10
 682:	08 95       	ret

00000684 <_ZN3SPI7setFreqEi>:
// as a parameter, 4000, 1000, 250, 125 are available options,
// defaults to 4000 if invalid parameter.
//=============================================================
void SPI::setFreq( int freq ) // sets prescaler based on requested freq in kHz, calculations assume a 16MHz clock speed.
{
	switch(freq)
 684:	6a 3f       	cpi	r22, 0xFA	; 250
 686:	71 05       	cpc	r23, r1
 688:	c1 f0       	breq	.+48     	; 0x6ba <_ZN3SPI7setFreqEi+0x36>
 68a:	6b 3f       	cpi	r22, 0xFB	; 251
 68c:	71 05       	cpc	r23, r1
 68e:	24 f4       	brge	.+8      	; 0x698 <_ZN3SPI7setFreqEi+0x14>
 690:	6d 37       	cpi	r22, 0x7D	; 125
 692:	71 05       	cpc	r23, r1
 694:	d9 f4       	brne	.+54     	; 0x6cc <_ZN3SPI7setFreqEi+0x48>
 696:	16 c0       	rjmp	.+44     	; 0x6c4 <_ZN3SPI7setFreqEi+0x40>
 698:	83 e0       	ldi	r24, 0x03	; 3
 69a:	68 3e       	cpi	r22, 0xE8	; 232
 69c:	78 07       	cpc	r23, r24
 69e:	41 f0       	breq	.+16     	; 0x6b0 <_ZN3SPI7setFreqEi+0x2c>
 6a0:	8f e0       	ldi	r24, 0x0F	; 15
 6a2:	60 3a       	cpi	r22, 0xA0	; 160
 6a4:	78 07       	cpc	r23, r24
 6a6:	91 f4       	brne	.+36     	; 0x6cc <_ZN3SPI7setFreqEi+0x48>
	{
	case 4000:
		SPCR = SPCR & 0b11111100; // prescaler = 4
 6a8:	8c b5       	in	r24, 0x2c	; 44
 6aa:	8c 7f       	andi	r24, 0xFC	; 252
 6ac:	8c bd       	out	0x2c, r24	; 44
		break;
 6ae:	08 95       	ret
	case 1000:
		SPCR = (SPCR & 0b11111100) | 0b00000001; // prescaler = 16
 6b0:	8c b5       	in	r24, 0x2c	; 44
 6b2:	8c 7f       	andi	r24, 0xFC	; 252
 6b4:	81 60       	ori	r24, 0x01	; 1
 6b6:	8c bd       	out	0x2c, r24	; 44
		break;
 6b8:	08 95       	ret
	case 250:
		SPCR = (SPCR & 0b11111100) | 0b00000010; // prescaler = 64
 6ba:	8c b5       	in	r24, 0x2c	; 44
 6bc:	8c 7f       	andi	r24, 0xFC	; 252
 6be:	82 60       	ori	r24, 0x02	; 2
 6c0:	8c bd       	out	0x2c, r24	; 44
		break;
 6c2:	08 95       	ret
	case 125:
		SPCR = SPCR | 0b00000011; // prescaler = 128
 6c4:	8c b5       	in	r24, 0x2c	; 44
 6c6:	83 60       	ori	r24, 0x03	; 3
 6c8:	8c bd       	out	0x2c, r24	; 44
		break;
 6ca:	08 95       	ret
	default:
		SPCR = SPCR & 0b11111100; // defaults to 4000 kHz
 6cc:	8c b5       	in	r24, 0x2c	; 44
 6ce:	8c 7f       	andi	r24, 0xFC	; 252
 6d0:	8c bd       	out	0x2c, r24	; 44
 6d2:	08 95       	ret

000006d4 <_ZN3SPIC1Ei>:
// to freq.
//=============================================================
 SPI::SPI( int freq )
{
	// only using master mode in the project so slave mode is not part of this SPI driver.
	DDRB = 0b00000111; // sets MOSI as output and SCK as output rest as input on port B.
 6d4:	27 e0       	ldi	r18, 0x07	; 7
 6d6:	24 b9       	out	0x04, r18	; 4
	SPCR = 0b01010000; // enable SPI and set mode to master
 6d8:	20 e5       	ldi	r18, 0x50	; 80
 6da:	2c bd       	out	0x2c, r18	; 44
	setFreq(freq);
 6dc:	0e 94 42 03 	call	0x684	; 0x684 <_ZN3SPI7setFreqEi>
}
 6e0:	08 95       	ret

000006e2 <_ZN3SPI9writeByteEh>:
// DESCR. : sends 1 byte of data out on MOSI,
// returns the response recieved from the reciever
//=============================================================
unsigned char SPI::writeByte( unsigned char data )
{
	SPDR = data; // starting the transmission
 6e2:	6e bd       	out	0x2e, r22	; 46
	while(!(SPSR &(1<<SPIF)));
 6e4:	0d b4       	in	r0, 0x2d	; 45
 6e6:	07 fe       	sbrs	r0, 7
 6e8:	fd cf       	rjmp	.-6      	; 0x6e4 <_ZN3SPI9writeByteEh+0x2>
	return SPDR;	
 6ea:	8e b5       	in	r24, 0x2e	; 46
}
 6ec:	08 95       	ret

000006ee <_ZN3SPI11recieveByteEv>:
// DESCR. : Recieves 1 byte of data, has to send out dummy data to MOSI to recieve.
// returns the response recieved from the reciever
//=============================================================
unsigned char SPI::recieveByte()
{
	SPDR = 0xFF; // sends don't care byte to transmit clocks.
 6ee:	8f ef       	ldi	r24, 0xFF	; 255
 6f0:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR &(1<<SPIF)));
 6f2:	0d b4       	in	r0, 0x2d	; 45
 6f4:	07 fe       	sbrs	r0, 7
 6f6:	fd cf       	rjmp	.-6      	; 0x6f2 <_ZN3SPI11recieveByteEv+0x4>
	return SPDR; // read data and return it.
 6f8:	8e b5       	in	r24, 0x2e	; 46
}
 6fa:	08 95       	ret

000006fc <_Z8InitUARTmhc>:
Parameters:
	BaudRate: Wanted Baud Rate.
	Databits: Wanted number of Data Bits.
*************************************************************************/
void InitUART(unsigned long BaudRate, unsigned char DataBit, char Parity)
{
 6fc:	0f 93       	push	r16
 6fe:	1f 93       	push	r17
 700:	dc 01       	movw	r26, r24
 702:	cb 01       	movw	r24, r22
 704:	52 2f       	mov	r21, r18
unsigned int TempUBRR;

  if ((BaudRate >= 110) && (BaudRate <= 115200) && (DataBit >=5) && (DataBit <= 8))
 706:	8c 01       	movw	r16, r24
 708:	9d 01       	movw	r18, r26
 70a:	0e 56       	subi	r16, 0x6E	; 110
 70c:	10 40       	sbci	r17, 0x00	; 0
 70e:	20 40       	sbci	r18, 0x00	; 0
 710:	30 40       	sbci	r19, 0x00	; 0
 712:	03 39       	cpi	r16, 0x93	; 147
 714:	61 ec       	ldi	r22, 0xC1	; 193
 716:	16 07       	cpc	r17, r22
 718:	61 e0       	ldi	r22, 0x01	; 1
 71a:	26 07       	cpc	r18, r22
 71c:	60 e0       	ldi	r22, 0x00	; 0
 71e:	36 07       	cpc	r19, r22
 720:	d8 f5       	brcc	.+118    	; 0x798 <_Z8InitUARTmhc+0x9c>
 722:	45 30       	cpi	r20, 0x05	; 5
 724:	c8 f1       	brcs	.+114    	; 0x798 <_Z8InitUARTmhc+0x9c>
 726:	49 30       	cpi	r20, 0x09	; 9
 728:	b8 f5       	brcc	.+110    	; 0x798 <_Z8InitUARTmhc+0x9c>
  { 
    // "Normal" clock, no multiprocessor mode (= default)
    UCSR0A = 0b00100000;
 72a:	20 e2       	ldi	r18, 0x20	; 32
 72c:	20 93 c0 00 	sts	0x00C0, r18
    // No interrupts enabled
    // Receiver enabled
    // Transmitter enabled
    // No 9 bit operation
    UCSR0B = 0b00011000;	
 730:	28 e1       	ldi	r18, 0x18	; 24
 732:	20 93 c1 00 	sts	0x00C1, r18
    // Asynchronous operation, 1 stop bit
    // Bit 2 and bit 1 controls the number of data bits
    UCSR0C = (DataBit-5)<<1;
 736:	45 50       	subi	r20, 0x05	; 5
 738:	44 0f       	add	r20, r20
 73a:	40 93 c2 00 	sts	0x00C2, r20
	// Set parity bits (if parity used)
	if (Parity == 'E')
 73e:	55 34       	cpi	r21, 0x45	; 69
 740:	31 f4       	brne	.+12     	; 0x74e <_Z8InitUARTmhc+0x52>
      UCSR0C |= 0b00100000;
 742:	e2 ec       	ldi	r30, 0xC2	; 194
 744:	f0 e0       	ldi	r31, 0x00	; 0
 746:	20 81       	ld	r18, Z
 748:	20 62       	ori	r18, 0x20	; 32
 74a:	20 83       	st	Z, r18
 74c:	07 c0       	rjmp	.+14     	; 0x75c <_Z8InitUARTmhc+0x60>
    else if (Parity == 'O')	  
 74e:	5f 34       	cpi	r21, 0x4F	; 79
 750:	29 f4       	brne	.+10     	; 0x75c <_Z8InitUARTmhc+0x60>
      UCSR0C |= 0b00110000;	
 752:	e2 ec       	ldi	r30, 0xC2	; 194
 754:	f0 e0       	ldi	r31, 0x00	; 0
 756:	20 81       	ld	r18, Z
 758:	20 63       	ori	r18, 0x30	; 48
 75a:	20 83       	st	Z, r18
    // Set Baud Rate according to the parameter BaudRate:
    // Select Baud Rate (first store "UBRRH--UBRRL" in local 16-bit variable,
    //                   then write the two 8-bit registers separately):
    TempUBRR = XTAL/(16*BaudRate) - 1;
 75c:	88 0f       	add	r24, r24
 75e:	99 1f       	adc	r25, r25
 760:	aa 1f       	adc	r26, r26
 762:	bb 1f       	adc	r27, r27
 764:	88 0f       	add	r24, r24
 766:	99 1f       	adc	r25, r25
 768:	aa 1f       	adc	r26, r26
 76a:	bb 1f       	adc	r27, r27
 76c:	9c 01       	movw	r18, r24
 76e:	ad 01       	movw	r20, r26
 770:	22 0f       	add	r18, r18
 772:	33 1f       	adc	r19, r19
 774:	44 1f       	adc	r20, r20
 776:	55 1f       	adc	r21, r21
 778:	22 0f       	add	r18, r18
 77a:	33 1f       	adc	r19, r19
 77c:	44 1f       	adc	r20, r20
 77e:	55 1f       	adc	r21, r21
 780:	60 e0       	ldi	r22, 0x00	; 0
 782:	74 e2       	ldi	r23, 0x24	; 36
 784:	84 ef       	ldi	r24, 0xF4	; 244
 786:	90 e0       	ldi	r25, 0x00	; 0
 788:	0e 94 10 04 	call	0x820	; 0x820 <__udivmodsi4>
 78c:	21 50       	subi	r18, 0x01	; 1
 78e:	30 40       	sbci	r19, 0x00	; 0
    // Write lower part of UBRR
    UBRR0L = TempUBRR;
 790:	20 93 c4 00 	sts	0x00C4, r18
    // Write upper part of UBRR
    UBRR0H = TempUBRR >> 8;
 794:	30 93 c5 00 	sts	0x00C5, r19
  }  
}
 798:	1f 91       	pop	r17
 79a:	0f 91       	pop	r16
 79c:	08 95       	ret

0000079e <_Z9CharReadyv>:
  Returns 0 (FALSE), if the UART has NOT received a new character.
  Returns value <> 0 (TRUE), if the UART HAS received a new character.
*************************************************************************/
unsigned char CharReady()
{
   return UCSR0A & (1<<7);
 79e:	80 91 c0 00 	lds	r24, 0x00C0
}
 7a2:	80 78       	andi	r24, 0x80	; 128
 7a4:	08 95       	ret

000007a6 <_Z8ReadCharv>:
Then this character is returned.
*************************************************************************/
char ReadChar()
{
  // Wait for new character received
  while ( (UCSR0A & (1<<7)) == 0 )
 7a6:	e0 ec       	ldi	r30, 0xC0	; 192
 7a8:	f0 e0       	ldi	r31, 0x00	; 0
 7aa:	80 81       	ld	r24, Z
 7ac:	88 23       	and	r24, r24
 7ae:	ec f7       	brge	.-6      	; 0x7aa <_Z8ReadCharv+0x4>
  {}                        
  // Then return it
  return UDR0;
 7b0:	80 91 c6 00 	lds	r24, 0x00C6
}
 7b4:	08 95       	ret

000007b6 <_Z8SendCharc>:
	Tegn : Character for sending. 
*************************************************************************/
void SendChar(char Tegn)
{
  // Wait for transmitter register empty (ready for new character)
  while ( (UCSR0A & (1<<5)) == 0 )
 7b6:	e0 ec       	ldi	r30, 0xC0	; 192
 7b8:	f0 e0       	ldi	r31, 0x00	; 0
 7ba:	90 81       	ld	r25, Z
 7bc:	95 ff       	sbrs	r25, 5
 7be:	fd cf       	rjmp	.-6      	; 0x7ba <_Z8SendCharc+0x4>
  {}
  // Then send the character
  UDR0 = Tegn;
 7c0:	80 93 c6 00 	sts	0x00C6, r24
}
 7c4:	08 95       	ret

000007c6 <_Z10SendStringPc>:
Sends 0 terminated string.
Parameter:
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
 7c6:	cf 93       	push	r28
 7c8:	df 93       	push	r29
 7ca:	ec 01       	movw	r28, r24
  // Repeat until zero-termination
  while (*Streng != 0)
 7cc:	88 81       	ld	r24, Y
 7ce:	88 23       	and	r24, r24
 7d0:	31 f0       	breq	.+12     	; 0x7de <_Z10SendStringPc+0x18>
/*************************************************************************
Sends 0 terminated string.
Parameter:
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
 7d2:	21 96       	adiw	r28, 0x01	; 1
{
  // Repeat until zero-termination
  while (*Streng != 0)
  {
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
 7d4:	0e 94 db 03 	call	0x7b6	; 0x7b6 <_Z8SendCharc>
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
  // Repeat until zero-termination
  while (*Streng != 0)
 7d8:	89 91       	ld	r24, Y+
 7da:	88 23       	and	r24, r24
 7dc:	d9 f7       	brne	.-10     	; 0x7d4 <_Z10SendStringPc+0xe>
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
    // Advance the pointer one step
    Streng++;
  }
}
 7de:	df 91       	pop	r29
 7e0:	cf 91       	pop	r28
 7e2:	08 95       	ret

000007e4 <_Z11SendIntegeri>:
Makes use of the C standard library <stdlib.h>.
Parameter:
    Tal: The integer to be converted and sent. 
*************************************************************************/
void SendInteger(int Tal)
{
 7e4:	cf 93       	push	r28
 7e6:	df 93       	push	r29
 7e8:	cd b7       	in	r28, 0x3d	; 61
 7ea:	de b7       	in	r29, 0x3e	; 62
 7ec:	27 97       	sbiw	r28, 0x07	; 7
 7ee:	0f b6       	in	r0, 0x3f	; 63
 7f0:	f8 94       	cli
 7f2:	de bf       	out	0x3e, r29	; 62
 7f4:	0f be       	out	0x3f, r0	; 63
 7f6:	cd bf       	out	0x3d, r28	; 61
char array[7];
  // Convert the integer to an ASCII string (array), radix = 10 
  itoa(Tal, array, 10);
 7f8:	be 01       	movw	r22, r28
 7fa:	6f 5f       	subi	r22, 0xFF	; 255
 7fc:	7f 4f       	sbci	r23, 0xFF	; 255
 7fe:	4a e0       	ldi	r20, 0x0A	; 10
 800:	50 e0       	ldi	r21, 0x00	; 0
 802:	0e 94 32 04 	call	0x864	; 0x864 <itoa>
  // - then send the string
  SendString(array);
 806:	ce 01       	movw	r24, r28
 808:	01 96       	adiw	r24, 0x01	; 1
 80a:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <_Z10SendStringPc>
}
 80e:	27 96       	adiw	r28, 0x07	; 7
 810:	0f b6       	in	r0, 0x3f	; 63
 812:	f8 94       	cli
 814:	de bf       	out	0x3e, r29	; 62
 816:	0f be       	out	0x3f, r0	; 63
 818:	cd bf       	out	0x3d, r28	; 61
 81a:	df 91       	pop	r29
 81c:	cf 91       	pop	r28
 81e:	08 95       	ret

00000820 <__udivmodsi4>:
 820:	a1 e2       	ldi	r26, 0x21	; 33
 822:	1a 2e       	mov	r1, r26
 824:	aa 1b       	sub	r26, r26
 826:	bb 1b       	sub	r27, r27
 828:	fd 01       	movw	r30, r26
 82a:	0d c0       	rjmp	.+26     	; 0x846 <__udivmodsi4_ep>

0000082c <__udivmodsi4_loop>:
 82c:	aa 1f       	adc	r26, r26
 82e:	bb 1f       	adc	r27, r27
 830:	ee 1f       	adc	r30, r30
 832:	ff 1f       	adc	r31, r31
 834:	a2 17       	cp	r26, r18
 836:	b3 07       	cpc	r27, r19
 838:	e4 07       	cpc	r30, r20
 83a:	f5 07       	cpc	r31, r21
 83c:	20 f0       	brcs	.+8      	; 0x846 <__udivmodsi4_ep>
 83e:	a2 1b       	sub	r26, r18
 840:	b3 0b       	sbc	r27, r19
 842:	e4 0b       	sbc	r30, r20
 844:	f5 0b       	sbc	r31, r21

00000846 <__udivmodsi4_ep>:
 846:	66 1f       	adc	r22, r22
 848:	77 1f       	adc	r23, r23
 84a:	88 1f       	adc	r24, r24
 84c:	99 1f       	adc	r25, r25
 84e:	1a 94       	dec	r1
 850:	69 f7       	brne	.-38     	; 0x82c <__udivmodsi4_loop>
 852:	60 95       	com	r22
 854:	70 95       	com	r23
 856:	80 95       	com	r24
 858:	90 95       	com	r25
 85a:	9b 01       	movw	r18, r22
 85c:	ac 01       	movw	r20, r24
 85e:	bd 01       	movw	r22, r26
 860:	cf 01       	movw	r24, r30
 862:	08 95       	ret

00000864 <itoa>:
 864:	fb 01       	movw	r30, r22
 866:	9f 01       	movw	r18, r30
 868:	e8 94       	clt
 86a:	42 30       	cpi	r20, 0x02	; 2
 86c:	c4 f0       	brlt	.+48     	; 0x89e <itoa+0x3a>
 86e:	45 32       	cpi	r20, 0x25	; 37
 870:	b4 f4       	brge	.+44     	; 0x89e <itoa+0x3a>
 872:	4a 30       	cpi	r20, 0x0A	; 10
 874:	29 f4       	brne	.+10     	; 0x880 <itoa+0x1c>
 876:	97 fb       	bst	r25, 7
 878:	1e f4       	brtc	.+6      	; 0x880 <itoa+0x1c>
 87a:	90 95       	com	r25
 87c:	81 95       	neg	r24
 87e:	9f 4f       	sbci	r25, 0xFF	; 255
 880:	64 2f       	mov	r22, r20
 882:	77 27       	eor	r23, r23
 884:	0e 94 63 04 	call	0x8c6	; 0x8c6 <__udivmodhi4>
 888:	80 5d       	subi	r24, 0xD0	; 208
 88a:	8a 33       	cpi	r24, 0x3A	; 58
 88c:	0c f0       	brlt	.+2      	; 0x890 <itoa+0x2c>
 88e:	89 5d       	subi	r24, 0xD9	; 217
 890:	81 93       	st	Z+, r24
 892:	cb 01       	movw	r24, r22
 894:	00 97       	sbiw	r24, 0x00	; 0
 896:	a1 f7       	brne	.-24     	; 0x880 <itoa+0x1c>
 898:	16 f4       	brtc	.+4      	; 0x89e <itoa+0x3a>
 89a:	5d e2       	ldi	r21, 0x2D	; 45
 89c:	51 93       	st	Z+, r21
 89e:	10 82       	st	Z, r1
 8a0:	c9 01       	movw	r24, r18
 8a2:	0c 94 53 04 	jmp	0x8a6	; 0x8a6 <strrev>

000008a6 <strrev>:
 8a6:	dc 01       	movw	r26, r24
 8a8:	fc 01       	movw	r30, r24
 8aa:	67 2f       	mov	r22, r23
 8ac:	71 91       	ld	r23, Z+
 8ae:	77 23       	and	r23, r23
 8b0:	e1 f7       	brne	.-8      	; 0x8aa <strrev+0x4>
 8b2:	32 97       	sbiw	r30, 0x02	; 2
 8b4:	04 c0       	rjmp	.+8      	; 0x8be <strrev+0x18>
 8b6:	7c 91       	ld	r23, X
 8b8:	6d 93       	st	X+, r22
 8ba:	70 83       	st	Z, r23
 8bc:	62 91       	ld	r22, -Z
 8be:	ae 17       	cp	r26, r30
 8c0:	bf 07       	cpc	r27, r31
 8c2:	c8 f3       	brcs	.-14     	; 0x8b6 <strrev+0x10>
 8c4:	08 95       	ret

000008c6 <__udivmodhi4>:
 8c6:	aa 1b       	sub	r26, r26
 8c8:	bb 1b       	sub	r27, r27
 8ca:	51 e1       	ldi	r21, 0x11	; 17
 8cc:	07 c0       	rjmp	.+14     	; 0x8dc <__udivmodhi4_ep>

000008ce <__udivmodhi4_loop>:
 8ce:	aa 1f       	adc	r26, r26
 8d0:	bb 1f       	adc	r27, r27
 8d2:	a6 17       	cp	r26, r22
 8d4:	b7 07       	cpc	r27, r23
 8d6:	10 f0       	brcs	.+4      	; 0x8dc <__udivmodhi4_ep>
 8d8:	a6 1b       	sub	r26, r22
 8da:	b7 0b       	sbc	r27, r23

000008dc <__udivmodhi4_ep>:
 8dc:	88 1f       	adc	r24, r24
 8de:	99 1f       	adc	r25, r25
 8e0:	5a 95       	dec	r21
 8e2:	a9 f7       	brne	.-22     	; 0x8ce <__udivmodhi4_loop>
 8e4:	80 95       	com	r24
 8e6:	90 95       	com	r25
 8e8:	bc 01       	movw	r22, r24
 8ea:	cd 01       	movw	r24, r26
 8ec:	08 95       	ret

000008ee <_exit>:
 8ee:	f8 94       	cli

000008f0 <__stop_program>:
 8f0:	ff cf       	rjmp	.-2      	; 0x8f0 <__stop_program>
